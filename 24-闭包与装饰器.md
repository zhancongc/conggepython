# 装饰器

## 引子

```python
def say_hello(somebody):
    print("Hello, %s" % (somebody or "World"))
```

现在你想记录函数的运行的时刻，很简单，用`datetime`库。

```python
import datetime

def say_hello(somebody):
    print(datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'))
    print("Hello, %s" % (somebody or "World"))

>>> say_hello('jack')
2019-04-25 03:43:54
Hello, jack
```

如果你有100个函数，都有这个需求，你需要把这条长的语句写100次！这不仅不`pythonic`，连简洁都谈不上。有没有什么简洁的方法呢？不难想到，把它写成函数调用。

```python
import datetime

def print_time():
    print(datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'))

def say_hello(somebody):
    print_time()
    print("Hello, %s" % (somebody or "World"))

>>> say_hello('jack')
2019-04-25 03:43:54
Hello, jack
```

每个函数，你都要插一行代码。唔，不够`pythonic`。

> 在python中，一切都是对象，都可以作为函数的返回值，包括函数。

那么我们可以在原来的函数基础上，添加print_time功能，形成一个新的say_hello函数。


```python
import datetime

def say_hello(somebody):
    print("Hello, %s" % (somebody or "World"))

def print_time(func):
    print(datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'))
    return func

>>> print_time(say_hello)('jack')
2019-04-25 03:43:54
Hello, jack
```

这么做虽然不改变原来的函数，但是函数调用需要重写，并非最优。python已经提供了最优雅的解决方案。

## 装饰器

```python
import datetime

def print_time(func):
    def wrapper(*args, **kwargs):
        print(datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'))
        func(*args, **kwargs)
    return wrapper

@print_time
def say_hello(somebody):
    print("Hello, %s" % (somebody or "World"))

>>> say_hello('jack')
2019-04-25 03:43:54
Hello, jack
```

看上去几乎完美的了，但是还有改进的空间。比如，现在的print_time只能打印执行时间，我们需要它打印任意时间，这个时间是外部传入的。也就是说，要为装饰器print_time加上一个外部传入的参数。

```python
import datetime

t = datetime.datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')

def print_time(timestamp):
    def wrapper(func):
        def inner_wrapper(*args, **kwargs):
            print(timestamp)
            func(*args, **kwargs)
        return inner_wrapper
    return wrapper

@print_time(t)
def say_hello(somebody):
    print("Hello, %s" % (somebody or "World"))

>>> say_hello('jack')
2019-04-25 05:42:14
Hello, jack
```

## 基于类的实现

> 装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重载了`__call__()`方法，那么这个对象就是callable的。



## 参考文章

1. [详解Python的装饰器](https://www.cnblogs.com/cicaday/p/python-decorator.html)，链接：<https://www.cnblogs.com/cicaday/p/python-decorator.html>
2. [python装饰器--原来如此简单](https://blog.csdn.net/u013858731/article/details/54971762)，链接：<https://blog.csdn.net/u013858731/article/details/54971762>










